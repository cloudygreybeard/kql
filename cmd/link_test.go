// Copyright 2026 cloudygreybeard
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.

package cmd

import (
	"os"
	"path/filepath"
	"strings"
	"testing"
)

func TestGetInput_FromArgs(t *testing.T) {
	result, err := getInput([]string{"test", "query"}, "")
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result != "test query" {
		t.Errorf("expected 'test query', got %q", result)
	}
}

func TestGetInput_FromFile(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "query.kql")
	if err := os.WriteFile(tmpFile, []byte("  T | take 10  \n"), 0644); err != nil {
		t.Fatalf("failed to create temp file: %v", err)
	}

	result, err := getInput(nil, tmpFile)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result != "T | take 10" {
		t.Errorf("expected 'T | take 10', got %q", result)
	}
}

func TestGetInput_EmptyFile(t *testing.T) {
	tmpDir := t.TempDir()
	tmpFile := filepath.Join(tmpDir, "empty.kql")
	if err := os.WriteFile(tmpFile, []byte("   \n  "), 0644); err != nil {
		t.Fatalf("failed to create temp file: %v", err)
	}

	_, err := getInput(nil, tmpFile)
	if err == nil {
		t.Error("expected error for empty file")
	}
}

func TestGetInput_FileNotFound(t *testing.T) {
	_, err := getInput(nil, "/nonexistent/path/query.kql")
	if err == nil {
		t.Error("expected error for non-existent file")
	}
}

func TestGetInput_NoInput(t *testing.T) {
	// When running in test, stdin is typically a terminal
	// so we expect an error when no args or file are provided
	_, err := getInput(nil, "")
	if err == nil {
		t.Error("expected error when no input provided")
	}
}

func TestGetInputFrom_FromStdin(t *testing.T) {
	stdin := strings.NewReader("query from stdin")
	// Pass a non-terminal check function
	isTerminal := func(f *os.File) bool { return false }

	result, err := getInputFrom(nil, "", stdin, isTerminal)
	if err != nil {
		t.Fatalf("unexpected error: %v", err)
	}
	if result != "query from stdin" {
		t.Errorf("expected 'query from stdin', got %q", result)
	}
}

func TestGetInputFrom_EmptyStdin(t *testing.T) {
	stdin := strings.NewReader("   \n  ")
	isTerminal := func(f *os.File) bool { return false }

	_, err := getInputFrom(nil, "", stdin, isTerminal)
	if err == nil {
		t.Error("expected error for empty stdin")
	}
}

func TestGetInputFrom_StdinReadError(t *testing.T) {
	stdin := errorReader{}
	isTerminal := func(f *os.File) bool { return false }

	_, err := getInputFrom(nil, "", stdin, isTerminal)
	if err == nil {
		t.Error("expected error for stdin read failure")
	}
}

// errorReader is a reader that always returns an error
type errorReader struct{}

func (e errorReader) Read(p []byte) (n int, err error) {
	return 0, os.ErrPermission
}

func TestRunLinkBuild(t *testing.T) {
	// Save and restore global flags
	origCluster := buildCluster
	origDatabase := buildDatabase
	origBaseURL := buildBaseURL
	defer func() {
		buildCluster = origCluster
		buildDatabase = origDatabase
		buildBaseURL = origBaseURL
	}()

	buildCluster = "help"
	buildDatabase = "Samples"
	buildBaseURL = ""

	err := runLinkBuild(nil, []string{"print 'hello'"})
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
}

func TestRunLinkExtract(t *testing.T) {
	// A valid deep link URL with base64-gzip encoded query (generated by link build)
	testURL := "https://dataexplorer.azure.com/clusters/help/databases/Samples?query=H4sIAAAAAAAA%2FyooyswrUVDPSM3JyVcHBAAA%2F%2F94g0IFDQAAAA%3D%3D"

	err := runLinkExtract(nil, []string{testURL})
	if err != nil {
		t.Errorf("unexpected error: %v", err)
	}
}

func TestRunLinkExtract_InvalidURL(t *testing.T) {
	err := runLinkExtract(nil, []string{"not-a-valid-url"})
	if err == nil {
		t.Error("expected error for invalid URL")
	}
}

func TestRunLinkBuild_NoCluster(t *testing.T) {
	// Test error when getInput fails (no input)
	origCluster := buildCluster
	origDatabase := buildDatabase
	defer func() {
		buildCluster = origCluster
		buildDatabase = origDatabase
	}()

	buildCluster = "help"
	buildDatabase = "Samples"

	// This should fail because no input is provided (no args, no file, and stdin is terminal)
	err := runLinkBuild(nil, nil)
	if err == nil {
		t.Error("expected error when no input provided")
	}
}

func TestRunLinkExtract_NoInput(t *testing.T) {
	// Save and restore global flags
	origFile := extractFile
	defer func() { extractFile = origFile }()

	extractFile = ""

	// This should fail because no input is provided
	err := runLinkExtract(nil, nil)
	if err == nil {
		t.Error("expected error when no input provided")
	}
}

func TestRunLinkBuild_EmptyCluster(t *testing.T) {
	// Save and restore global flags
	origCluster := buildCluster
	origDatabase := buildDatabase
	origBaseURL := buildBaseURL
	defer func() {
		buildCluster = origCluster
		buildDatabase = origDatabase
		buildBaseURL = origBaseURL
	}()

	// Empty cluster should cause Build to fail
	buildCluster = ""
	buildDatabase = "Samples"
	buildBaseURL = ""

	err := runLinkBuild(nil, []string{"print 'hello'"})
	if err == nil {
		t.Error("expected error for empty cluster")
	}
}
